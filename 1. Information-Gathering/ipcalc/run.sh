#!/bin/bash
print_help() {
    cat <<EOF
╔════ Run ipcalc on a given network address ════╗
╠═══════════════════════════════════════════════╣
║ Feature(s):                                   ║
║   - Network subnetting                        ║ 
╠═══════════════════════════════════════════════╣
║ Usage: ./run <address> [--div <divisions>]    ║
║   <address>────> Network address to calculate ║
║   <divisions>──> Number of subnets to create  ║
╚═══════════════════════════════════════════════╝
EOF
}

# Calculate the ceiling of log2(n)
# to determine the new mask
ceil_log2() {
    n="$1"
    if (( n <= 1 )); then
        echo 0
    else
        echo "$((1 + $(ceil_log2 $((n / 2)))))"
    fi
}

# Split a network into a given number of subnets
# and print the ipcalc of each subnet
split_network() {
    ip=$(echo "$ADDRESS" | cut -d'/' -f1)
    mask=$(echo "$ADDRESS" | cut -d'/' -f2)
    count="$1"
    clog=$(ceil_log2 "$count")
    mask=$((mask + clog))
    if (( mask > 32 ))
    then
        echo "Can not split $ADDRESS into $count subnets"
        exit 2
    fi
    IFS=. read -r ip1 ip2 ip3 ip4 <<< "$ip"
    count=$((2**mod))
    for (( i = 0; i < count; i++ ))
    do
        first="$((ip4 + i*(2**(32-mask))))"
        ip="$ip1.$ip2.$ip3.$first"

        echo "══════════════Sub-Network $ip/$mask"
        ipcalc "$ip/$mask"
    done
}

#═════════════ S T A R T ═════════════#
if [ $# -lt 1 ]; then
    print_help
    exit 1
fi
if [[ "$1" == "-h" ]]; then
    print_help
    exit 0
fi

ADDRESS="$1"
echo "══════════════Network $ADDRESS"
ipcalc "$ADDRESS"
if [[ "$2" == "--div" ]] && [ $# -eq 3 ]
then
    split_network "$3"
fi
